/*************************************************
*
*readme
*创建无名消息灯用于进程间通信
*功能：服务器在信号灯中进行P操作，客户端进行V操作
*NOTES:代码并不健壮,
*1.有些系统在默认初始化信号量为0，但是并不是所有的都是0
*父子进程之间，考虑使用posix的sem
*2.信号灯直接取消，不用等待其他进程退出
*sops.sem_flg = 0 | SEM_UNDO时，进程退出时，释放信号量
*退出包括正常退出和异常退出
*3.信号灯不可被两个进程重复删除
*
**************************************************/
#include <stdio.h>
#include <sys/ipc.h>
#include <errno.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/sem.h>
union semun {
   int              val;    // Value for SETVAL 
   struct semid_ds *buf;    // Buffer for IPC_STAT, IPC_SET 
   unsigned short  *array;  // Array for GETALL, SETALL 
   struct seminfo  *__buf;  // Buffer for IPC_INFO
							// (Linux-specific) 
};


int main()
{
	int semid;
	char *ptr;
	void *pret;
	pid_t pid;
	int ret;
	int j;
	union semun semdate;
	struct  sembuf sops;
	key_t key;
	
	key = ftok("./a.c", 'a');							// 生成key
	if(key < 0){
		printf("failed to call ftok!\n");
		printf("errno value: %d, it means: %s\n",
				errno, strerror(errno));
		return -1;
	}
	
    semid = semget(key, 1, IPC_CREAT | IPC_EXCL | 0777);// 创建无名信号灯，内含1个信号量
	if( (semid < 0) && ( EEXIST == errno)){
		// 信号已经存在
	semid = semget(key, 1, 0777);						// 获取已创建无名信号灯，内含1个信号量
	}
	printf("semid is:%d\n", semid);

	ret = semctl(semid, 0, GETVAL);					// 读取信号量值
	printf("semval is:%d\n", ret);					// 打印信号量值
	
	sops.sem_num = 0;								// 第一个信号量
	sops.sem_op = -1;								// 释放信号量
	sops.sem_flg = 0;								// 阻塞等待
	ret = semop(semid, &sops, 1);					// v操作
	if(ret < 0){
		printf("failed to call semctl!\n");
		printf("errno value: %d, it means: %s\n",
				errno, strerror(errno));
		return -1;
	}
	
	for(j = 0; j <= 10; j++){
		printf("j value is:%d\n", j);
	}
	return 1;
}