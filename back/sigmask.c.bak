/*************************************************
*
*readme
*用于测试信号捕捉
*功能：阻塞并捕捉SIGQUIT（ctrl+\）信号
*NOTES:信号多次发生且被阻塞并不能进行排队，只捕捉一次
*sigprocmask还未返回就接收到了信号
**************************************************/
#include <stdio.h>
#include <signal.h>
#include <errno.h>

void func(int sig)
{
	printf("receive signal:%d\n", sig);
}

int main()
{
	int ret;
	
	sigset_t SigNewSet, SigOldSet, Sigset;
	if(SIG_ERR == signal(SIGQUIT, func)){					// 捕捉信号
		printf("failed to call signal!\n");
		return -1;
	}
	sigemptyset(&SigNewSet);
	sigaddset(&SigNewSet, SIGQUIT);							// 添加信号
	ret = sigprocmask(SIG_BLOCK, &SigNewSet, &SigOldSet);	// 阻塞信号
	if( ret < 0){
		printf("errno value: %d, it means: %s\n",
				errno, strerror(errno));
		return -1;
	}
	printf("come to sleep!\n");
	sleep(10);												// 休眠等待信号发生
	sigpending(&Sigset);									// 获取被阻塞信号
	ret = sigismember(&Sigset, SIGQUIT);					// 检测信号是否被阻塞
	if( 1== ret){
		printf("SIGQUIT is blocked!\n");
	}
	else if(0 == ret){
		printf("SIGQUIT is not blocked!\n");
	}
	else{
		printf("failed to call sigismember!\n");
		return -1;
	}
	
	ret = sigprocmask(SIG_SETMASK, &SigOldSet, NULL);		// 解除阻塞信号
		if( ret < 0){
		printf("errno value: %d, it means: %s\n",
				errno, strerror(errno));
		return -1;
	}
	
	sleep(20);												// 休眠等待信号发生	
	printf("wake up!\n");
	return 1;
}